import type { DetailBlock } from "~/data/portfolio"

export const problemDetailById: Record<string, DetailBlock[]> = {
    /* =========================================================
     * 네이버 블로그 자동 발행 프로그램
     * ========================================================= */
    "problem-blog-publishing-automation": [
        {
            type: "paragraph",
            text:
                "브랜드스퀘어 마케팅팀(2025.07~2025.09)에서 네이버 블로그를 팀원들이 손수 작성중이었습니다.\n " +
                "관리하는 업체가 늘어남에 따라 인력이 더 필요한 상황이 발생하게 되어 제가 제안을 하게 되었습니다.\n" +
                "글의 원고를 ChatGPT를 통해 도움을 받고 있던 상황이었기에 이것을 자동화 할 수 있겠다는 생각이 들어 제안하여 직접 설계, 개발을 시작했습니다.\n "
        },
        {
            type: "bullets",
            items: [
                "문제: 원고 작성부터 발행까지 전 과정이 사람 손에 의존한 반복 작업",
                "제약: 네이버 발행 환경의 UI 변동성, 이미지의 경우 업체별, 콘텐츠별 요구사항이 달라 자동 생성보다 직접 준비가 필요",
                "목표: 비개발자도 사용할 수 있는 ‘도구’ 형태로 자동화(설치형 GUI) + 실패 대응까지 포함",
            ],
        },
        {
            type: "image",
            src: "/images/problem/blog-diagram.png",
            alt: "블로그 발행 파이프라인 다이어그램",
            caption:
                "사람이 직접 수행하던 블로그 작성·검수·발행 업무를 하나의 프로그램 흐름으로 대체한 구조",
        },
        {
            type: "paragraph",
            text:
                "이 프로그램의 핵심 설계는 사람이 직접 수행하던 블로그 작성과 발행 준비 업무를 프로그램이 대신 처리하도록 흐름을 구성하는 것이었습니다.\n" +
                "엑셀 업로드를 시작으로 사진 분석, 원고 작성, 블로그 작성 화면 구성까지를 하나의 연속된 과정으로 묶어, 사용자는 최종 결과를 확인하고 발행 여부만 판단하면 되도록 설계했습니다."
        },
        {
            type: "paragraph",
            text:
                "이 프로젝트에서 가장 어려웠던 부분은 자동화 자체보다 ChatGPT API와 Claude API를 원하는 방향으로 제어하는 일이었습니다.\n" +
                "단순히 프롬프트를 던지는 것만으로는 실제 블로그 원고로 쓰기 어려운 결과가 나오는 경우가 많았기 때문에,\n " +
                "사진 설명, 문단 구조, 톤 앤 매너, 이미지 배치 위치까지 포함해 일관된 결과가 나오도록 프롬프트를 반복적으로 설계·조정했습니다.\n" +
                "특히 ChatGPT는 사진을 텍스트로 구조화하는 역할, Claude는 장문 원고를 작성하는 역할로 분리해 각각의 강점을 살리는 방향으로 접근했습니다."
        },
        {
            type: "bullets",
            items: [
                "예외 팝업/패널 대응: 자동 닫기/취소/재시도 등 방어 로직",
                "실패 복구: 특정 단계 실패 시 해당 단계부터 일정 횟수 재시도 가능하도록 흐름 분리",
                "안정성 우선 정책: 일정 횟수 실패 시 다음 job으로 패스(무한 루프 방지)",
            ],
        },
        {
            type: "paragraph",
            text:
                "이 프로젝트를 통해 ‘자동화 스크립트’가 아니라 ‘운영 가능한 제품 형태(도구)’로 만드는 경험을 확실히 쌓았습니다.\n " +
                "LLM을 제가 원하는 방향으로 제어하는 것이 주요했고 회사에 맞춤형으로 제공하도록 설계했던 점이 사용자의 만족도를 끌어올렸습니다.",
        },
        {
            type: "bullets",
            items: [
                "도구화 관점: 설치형(Electron) + GUI + 로그/진행률로 실사용 가능하게 구성",
                "확장성: 입력 모드/템플릿 추가로 글 유형 확장 가능",
            ],
        },
    ],

    /* =========================================================
     * 사내 반복 업무 자동화
     * ========================================================= */
    "problem-internal-automation": [
        {
            type: "paragraph",
            text:
                "사내 업무를 진행하면서 반복적으로 발생하는 작업들이 여럿 있었습니다.\n\n" +
                "영업을 위한 전화번호 수집, 고객 대상 메시지 전송, 이미지 전달 등은 매번 사람이 직접 수행하고 있었고, 작업량이 늘어날수록 시간 소모와 실수가 함께 증가하는 구조였습니다.\n\n" +
                "이러한 반복 업무를 사람 대신 프로그램이 수행하도록 전환하기 위해, Python 기반 사내 자동화 프로그램을 개발했습니다."
        },
        {
            type: "bullets",
            items: [
                "대상 업무: 전화번호 수집, 메시지 전송, 이미지 전달 등 반복적이고 규칙적인 사내 작업",
                "문제: 똑같은 단순 반복 작업을 하게 되어 시간 낭비 및 실수가 나올 확률 증가",
                "목표: 사람이 직접 하지 않아도 되는 업무를 프로그램이 대신 수행하도록 구조 전환",
            ],
        },
        {
            type: "paragraph",
            text:
                "대표적으로는 카카오톡 자동 메시지 전송 프로그램과, 영업 콜 DB 구축을 위한 전화번호 자동 수집 프로그램을 개발했습니다.\n\n" +
                "단순한 스크립트 실행이 아니라, 실제 업무 담당자가 사용할 수 있도록 실행·중지·설정이 가능한 도구 형태로 구성하는 데 중점을 두었습니다."
        },
        {
            type: "bullets",
            items: [
                "카카오톡 자동 메시지 전송: 텍스트 및 이미지 메시지를 지정한 조건에 따라 자동 전송",
                "전화번호 자동 수집: 네이버·다음 지도 페이지에서 업체 전화번호를 자동으로 수집해 엑셀 변환하여 DB화",
                "도구화: Python을 통한 로직과 GUI를 결합해 비개발자도 실행 가능하도록 구성",
            ],
        },
        {
            type: "paragraph",
            text:
                "자동화 구현에서 중요하게 본 점은 '사람이 하는 일을 줄이자' 였습니다.\n"
        },
        {
            type: "bullets",
            items: [
                "실행 기준: 작업 단위별로 분리해 반복 실행에 적합한 구조로 설계",
                "현실 반영: 페이지 로딩 지연이나 UI 변경을 고려한 여유 있는 자동화 흐름",
                "운영 전제: 반복 사용을 고려해 세션·프로세스 정리를 기본 설계에 포함",
            ],
        },
        {
            type: "paragraph",
            text:
                "이 자동화를 통해 사내 직원들이 반복적으로 소요하던 시간을 줄이고, 보다 중요한 업무에 집중할 수 있는 환경을 만들었습니다.\n\n" +
                "메시지 전송이나 데이터 수집과 같이 사람이 직접 하지 않아도 되는 작업은 프로그램이 담당하도록 전환해, 전체적인 업무 처리 효율을 개선하는 데 기여했습니다."
        },
    ],


    /* =========================================================
     * 관리자 시스템 설계/구현
     * ========================================================= */
    "problem-admin-system-design": [
        {
            type: "paragraph",
            text:
                "사내에서 기존에 노후된 관리자 페이지와 따로 엑섹등을 통해 업무를 처리하고 있었고, 이러한 업무 방식에 불편함을 느끼고 있어 하나로 통합된 관리자 페이지와 API 서버를 처음부터 설계·구현했습니다.\n\n" +
                "단순히 데이터를 나열하는 화면이 아니라, 실제 실무자가 업무를 처리하는 흐름을 기준으로 화면 구조와 기능 우선순위를 정리하는 데 초점을 맞췄으며 모든 업무를 웹에서 관리,모니터링 하도록 진행했습니다."
        },
        {
            type: "bullets",
            items: [
                "대상: 상담·영업·처리 상태 등 사내 업무 전반",
                "문제: 엑셀·메신저·개별 도구·기존 어드민으로 분산된 업무 관리",
                "목표: 업무 상태와 이력을 한 곳에서 관리할 수 있는 관리자 시스템 구축",
            ],
        },
        {
            type: "image",
            src: "/images/problem/problem-admin-system-design.png",
            alt: "사내 관리자 시스템 구조",
            caption:
                "분산된 사내 업무 데이터를 하나의 관리자 시스템으로 통합한 구조",
        },
        {
            type: "paragraph",
            text:
                "관리자 시스템은 단순 CRUD 화면이 아니라, 업무의 ‘상태 변화’와 ‘담당자 흐름’을 중심으로 설계했습니다.\n\n" +
                "각 업무는 상태(enum)를 기준으로 관리되며, 담당자 변경이나 처리 이력은 기록으로 남겨 이후 추적과 확인이 가능하도록 구성했습니다."
        },
        {
            type: "bullets",
            items: [
                "상태 중심 설계: 업무 진행 상태를 enum 기반으로 관리",
                "이력 관리: 담당자 변경 및 주요 처리 내용을 히스토리로 기록",
                "권한 고려: 사용자 권한에 따라 접근 가능 기능 분리",
            ],
        },
        {
            type: "paragraph",
            text:
                "프론트엔드는 Nuxt 기반으로 구성해 목록 조회, 상세 보기, 수정 작업이 빠르게 이루어질 수 있도록 했고, 백엔드는 Spring Boot 기반으로 API 서버를 통해 화면과 데이터를 명확히 분리했습니다.\n"
        },
        {
            type: "paragraph",
            text:
                "관리자 시스템은 사내 업무용 시스템이라는 특성상 접근 범위와 권한 관리가 중요했습니다.\n\n" +
                "관리자 페이지는 회사 내부 네트워크에서만 접근 가능하도록 제한하고, 고객이 확인해야 하는 계약서 페이지는 외부에서도 접근할 수 있도록 분리했습니다. 이 접근 경로 분리는 Nginx 리버스 프록시를 통해 처리했습니다.\n\n" +
                "또한 사용자 권한에 따라 접근 가능한 기능과 화면을 구분하고, 관리자는 대시보드를 통해 업무 현황과 주요 지표를 한눈에 확인할 수 있도록 구성했습니다."
        },
        {
            type: "bullets",
            items: [
                "접근 제어: 내부 IP 전용 관리자 페이지 / 외부 공개 계약서 페이지 분리",
                "권한 기반 UI: 관리자·일반 사용자 역할에 따른 기능 및 화면 제어",
                "대시보드 제공: 이달의 우수사원, 업무 처리 현황 등 핵심 지표 시각화",
            ],
        },

        {
            type: "paragraph",
            text:
                "이 시스템을 통해 사내 업무 현황을 한눈에 파악할 수 있게 되었고, 업무 진행 상황에 대한 공유와 관리가 훨씬 수월해졌습니다.\n\n" +
                "개별 담당자의 기억이나 메신저 대화에 의존하던 업무 관리 방식에서 벗어나, 시스템을 기준으로 업무를 판단할 수 있는 환경을 만드는 데 기여했습니다."
        },

        {
            type: "bullets",
            items: [
                "업무 가시성 확보: 상태·담당자·이력을 한 화면에서 확인",
                "관리 효율 개선: 반복 확인·문의 감소",
                "조직 기여: 개인 의존적인 업무 관리 방식에서 시스템 중심으로 전환",
            ],
        },
    ],

    /* =========================================================
     * 잦은 요구사항 변경 대응
     * ========================================================= */
    "problem-requirement-change": [
        {
            type: "paragraph",
            text:
                "어드민과 자동화 도구를 운영하다 보면 요구사항 변경은 피할 수 없다고 판단했습니다.\n\n" +
                "특히 상담·업무 관리 시스템에서는 상태가 고정되지 않고, 운영 과정에서 새로운 상태가 계속 추가되는 경우가 많았습니다. 그래서 저는 상태가 늘어나는 상황을 전제로 설계를 시작했습니다."
        },
        {
            type: "paragraph",
            text:
                "핵심은 업무 상태를 코드(enum)에 고정하지 않고 DB에서 관리하도록 분리한 점입니다.\n\n" +
                "관리자가 관리자 화면에서 새로운 상태를 등록하면, 별도의 개발 작업 없이 바로 업무 흐름과 화면에 반영되도록 구성했습니다. 이를 통해 상태 추가를 개발 이슈가 아니라 운영 설정의 문제로 전환할 수 있었습니다."
        },
        {
            type: "bullets",
            items: [
                "상태 값 관리: 실제 업무 상태는 DB 테이블에서 관리",
                "운영 대응: 관리자가 상태 추가·수정 시 즉시 반영",
                "개발 부담 감소: 상태 추가로 인한 코드 수정 최소화",
            ],
        },
        {
            type: "paragraph",
            text:
                "다만 모든 로직을 문자열 기반으로 처리하지는 않았습니다.\n\n" +
                "상태에 따른 처리 기준이나 분기 로직은 enum으로 분리해 관리했고, 실제 상태 값은 이 기준에 매핑되도록 설계했습니다. 이 방식으로 상태가 늘어나더라도 기존 비즈니스 로직은 변경하지 않도록 역할을 나눴습니다."
        },
        {
            type: "bullets",
            items: [
                "역할 분리: 상태 값(DB) / 처리 기준(enum)",
                "확장 안정성: 신규 상태 추가 시 기존 로직 영향 최소화",
                "유지보수성: 변경 지점이 명확해 테스트 범위 예측 가능",
            ],
        },
        {
            type: "paragraph",
            text:
                "이 경험을 통해 저는 요구사항을 예측하기보다, 요구사항이 늘어나는 구조 자체를 받아들이고 시스템에 맡기는 설계를 선호하게 되었습니다.\n\n" +
                "그 결과 변경이 들어올 때마다 급하게 구조를 수정하기보다는, 이미 준비된 방식으로 안정적으로 대응할 수 있었습니다."
        },
    ]
}
